package tests

import (
	"paserati/pkg/builtins"
	"paserati/pkg/compiler"
	"paserati/pkg/lexer"
	"paserati/pkg/parser"
	"paserati/pkg/vm"
	"testing"
)

const templateCompilerDebug = false // Enable for debugging

// templateExecutionTestCase represents a single template literal execution test
type templateExecutionTestCase struct {
	name     string
	input    string
	expected string
}

func TestTemplateLiteralExecution(t *testing.T) {
	testCases := []templateExecutionTestCase{
		{
			name:     "Simple Template",
			input:    "`hello world`",
			expected: "hello world",
		},
		{
			name:     "Empty Template",
			input:    "``",
			expected: "",
		},
		{
			name:     "Template with Variable",
			input:    "let name = 'Alice'; `hello ${name}`",
			expected: "hello Alice",
		},
		{
			name:     "Template with Multiple Variables",
			input:    "let x = 5; let y = 3; `${x} + ${y} = ${x + y}`",
			expected: "5 + 3 = 8",
		},
		{
			name:     "Template with Numbers",
			input:    "let num = 42; `The answer is ${num}`",
			expected: "The answer is 42",
		},
		{
			name:     "Template with Expressions",
			input:    "let a = 10; let b = 20; `Result: ${a * b + 5}`",
			expected: "Result: 205",
		},
		{
			name:     "Template Only Interpolations",
			input:    "let x = 'A'; let y = 'B'; `${x}${y}`",
			expected: "AB",
		},
		{
			name:     "Template with String Concatenation",
			input:    "let first = 'Hello'; let second = 'World'; `${first + ' ' + second}!`",
			expected: "Hello World!",
		},
	}

	for _, testCase := range testCases {
		t.Run(testCase.name, func(t *testing.T) {
			if templateCompilerDebug {
				t.Logf("Testing: %s", testCase.input)
			}

			// Lexing
			l := lexer.NewLexer(testCase.input)

			// Parsing
			p := parser.NewParser(l)
			program, parseErrors := p.ParseProgram()

			if len(parseErrors) > 0 {
				t.Fatalf("Parse errors: %v", parseErrors)
			}

			// Compilation
			c := compiler.NewCompiler()
			chunk, compileErrors := c.Compile(program)

			if len(compileErrors) > 0 {
				t.Fatalf("Compile errors: %v", compileErrors)
			}

			// Execution
			vmInstance := vm.NewVM()
			vmInstance.AddStandardCallbacks(builtins.GetStandardInitCallbacks())
			if err := vmInstance.InitializeWithCallbacks(); err != nil {
				t.Fatalf("VM initialization failed: %v", err)
			}
			result, runtimeErrors := vmInstance.Interpret(chunk)

			if len(runtimeErrors) > 0 {
				t.Fatalf("Runtime errors: %v", runtimeErrors)
			}

			// Verify result
			if !vm.IsString(result) {
				t.Errorf("Expected string result, got %s (%s)", result.ToString(), result.TypeName())
			}

			actualStr := vm.AsString(result)
			if actualStr != testCase.expected {
				t.Errorf("Expected '%s', got '%s'", testCase.expected, actualStr)
			}

			if templateCompilerDebug {
				t.Logf("âœ“ Result: '%s'", actualStr)
				t.Logf("Bytecode:\n%s", chunk.DisassembleChunk("test"))
			}
		})
	}
}

func TestTemplateLiteralBytecodeGeneration(t *testing.T) {
	// Test that OpStringConcat is being generated for template literals
	input := "let name; `hello ${name}`"

	l := lexer.NewLexer(input)
	p := parser.NewParser(l)
	program, parseErrors := p.ParseProgram()

	if len(parseErrors) > 0 {
		t.Fatalf("Parse errors: %v", parseErrors)
	}

	c := compiler.NewCompiler()
	chunk, compileErrors := c.Compile(program)

	if len(compileErrors) > 0 {
		t.Fatalf("Compile errors: %v", compileErrors)
	}

	// Check that OpStringConcat appears in the bytecode
	bytecode := chunk.DisassembleChunk("test")
	if templateCompilerDebug {
		t.Logf("Generated bytecode:\n%s", bytecode)
	}

	// Look for OpStringConcat in the disassembled output
	found := false
	for i := 0; i < len(chunk.Code); i++ {
		if vm.OpCode(chunk.Code[i]) == vm.OpStringConcat {
			found = true
			break
		}
	}

	if !found {
		t.Error("Expected OpStringConcat to be generated for template literal, but it was not found")
	}
}
